package dovecot

import (
	"bufio"
	"database/sql"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog/log"
)

// Config holds the configuration for Dovecot/Postfix file sync
type Config struct {
	// Dovecot paths
	DovecotPasswdFile string // e.g., /etc/dovecot/users
	DovecotUserDBFile string // e.g., /etc/dovecot/userdb

	// Postfix paths
	PostfixVirtualMailbox string // e.g., /etc/postfix/vmailbox
	PostfixVirtualAlias   string // e.g., /etc/postfix/virtual

	// Mail storage
	MailDir string // e.g., /var/mail/vhosts

	// UID/GID for mail storage
	VmailUID int
	VmailGID int
}

// DefaultConfig returns the default configuration
func DefaultConfig() *Config {
	return &Config{
		DovecotPasswdFile:     "/etc/dovecot/users",
		DovecotUserDBFile:     "/etc/dovecot/userdb",
		PostfixVirtualMailbox: "/etc/postfix/vmailbox",
		PostfixVirtualAlias:   "/etc/postfix/virtual",
		MailDir:               "/var/mail/vhosts",
		VmailUID:              5000,
		VmailGID:              5000,
	}
}

// Syncer handles synchronization between the database and mail server config files
type Syncer struct {
	db     *sql.DB
	config *Config
}

// NewSyncer creates a new syncer with the given database and configuration
func NewSyncer(db *sql.DB, config *Config) *Syncer {
	if config == nil {
		config = DefaultConfig()
	}
	return &Syncer{db: db, config: config}
}

// SyncAll synchronizes all mail configuration files
func (s *Syncer) SyncAll() error {
	log.Info().Msg("Starting full mail configuration sync")

	if err := s.SyncDovecotUsers(); err != nil {
		return fmt.Errorf("dovecot users sync failed: %w", err)
	}

	if err := s.SyncPostfixMaps(); err != nil {
		return fmt.Errorf("postfix maps sync failed: %w", err)
	}

	log.Info().Msg("Mail configuration sync completed successfully")
	return nil
}

// SyncDovecotUsers generates Dovecot authentication files from the database
func (s *Syncer) SyncDovecotUsers() error {
	log.Info().Msg("Syncing Dovecot user files")

	// Query all active mailboxes
	rows, err := s.db.Query(`
		SELECT m.email, m.password_hash, m.quota_bytes, d.domain
		FROM mailboxes m
		JOIN mail_domains d ON m.domain_id = d.id
		WHERE m.active = TRUE AND d.active = TRUE
	`)
	if err != nil {
		return fmt.Errorf("failed to query mailboxes: %w", err)
	}
	defer rows.Close()

	// Collect user data
	type mailboxData struct {
		email    string
		password string
		quota    int64
		domain   string
	}
	var mailboxes []mailboxData

	for rows.Next() {
		var m mailboxData
		if err := rows.Scan(&m.email, &m.password, &m.quota, &m.domain); err != nil {
			log.Warn().Err(err).Msg("Failed to scan mailbox row")
			continue
		}
		mailboxes = append(mailboxes, m)
	}

	// Generate Dovecot passwd file
	// Format: user:password:uid:gid:(gecos):home:(shell):extra_fields
	passwdContent := strings.Builder{}
	passwdContent.WriteString("# Generated by PSFX Admin - DO NOT EDIT MANUALLY\n")

	for _, m := range mailboxes {
		// Home directory: /var/mail/vhosts/domain/user
		home := filepath.Join(s.config.MailDir, m.domain, strings.Split(m.email, "@")[0])

		// Extra fields for quota
		extraFields := ""
		if m.quota > 0 {
			extraFields = fmt.Sprintf("userdb_quota_rule=*:bytes=%d", m.quota)
		}

		// Dovecot passwd format
		// Note: When scheme=BLF-CRYPT is specified in dovecot passdb config,
		// the password hash should NOT have the {BLF-CRYPT} prefix in the file.
		// The bcrypt hash from Go (e.g., $2a$10$...) is used directly.
		line := fmt.Sprintf("%s:%s:%d:%d::%s::%s\n",
			m.email,
			m.password,
			s.config.VmailUID,
			s.config.VmailGID,
			home,
			extraFields,
		)
		passwdContent.WriteString(line)
	}

	// Write to file atomically
	// Use 0644 so dovecot auth process can read it (password hashes are bcrypt-protected)
	if err := atomicWriteFile(s.config.DovecotPasswdFile, []byte(passwdContent.String()), 0644); err != nil {
		return fmt.Errorf("failed to write dovecot passwd file: %w", err)
	}

	// Create mail directories for new users
	for _, m := range mailboxes {
		home := filepath.Join(s.config.MailDir, m.domain, strings.Split(m.email, "@")[0])
		if err := ensureMailDir(home, s.config.VmailUID, s.config.VmailGID); err != nil {
			log.Warn().Err(err).Str("email", m.email).Str("home", home).Msg("Failed to create mail directory")
		}
	}

	log.Info().Int("count", len(mailboxes)).Msg("Dovecot users synced")
	return nil
}

// SyncPostfixMaps generates Postfix virtual mailbox and alias maps
func (s *Syncer) SyncPostfixMaps() error {
	log.Info().Msg("Syncing Postfix virtual maps")

	// Generate virtual mailbox map
	if err := s.syncVirtualMailbox(); err != nil {
		return fmt.Errorf("virtual mailbox sync failed: %w", err)
	}

	// Generate virtual alias map
	if err := s.syncVirtualAlias(); err != nil {
		return fmt.Errorf("virtual alias sync failed: %w", err)
	}

	return nil
}

func (s *Syncer) syncVirtualMailbox() error {
	// Query all active mailboxes
	rows, err := s.db.Query(`
		SELECT m.email, d.domain
		FROM mailboxes m
		JOIN mail_domains d ON m.domain_id = d.id
		WHERE m.active = TRUE AND d.active = TRUE
		ORDER BY m.email
	`)
	if err != nil {
		return fmt.Errorf("failed to query mailboxes: %w", err)
	}
	defer rows.Close()

	// Format: email domain/user/
	content := strings.Builder{}
	content.WriteString("# Generated by PSFX Admin - DO NOT EDIT MANUALLY\n")

	count := 0
	for rows.Next() {
		var email, domain string
		if err := rows.Scan(&email, &domain); err != nil {
			continue
		}
		localPart := strings.Split(email, "@")[0]
		content.WriteString(fmt.Sprintf("%s\t%s/%s/\n", email, domain, localPart))
		count++
	}

	// Write and postmap
	if err := atomicWriteFile(s.config.PostfixVirtualMailbox, []byte(content.String()), 0644); err != nil {
		return fmt.Errorf("failed to write vmailbox: %w", err)
	}

	if err := runPostmap(s.config.PostfixVirtualMailbox); err != nil {
		return fmt.Errorf("postmap vmailbox failed: %w", err)
	}

	log.Info().Int("count", count).Msg("Postfix virtual mailbox map synced")
	return nil
}

func (s *Syncer) syncVirtualAlias() error {
	// Query all active aliases
	rows, err := s.db.Query(`
		SELECT a.source_email, a.destination_email
		FROM mail_aliases a
		JOIN mail_domains d ON a.domain_id = d.id
		WHERE a.active = TRUE AND d.active = TRUE
		ORDER BY a.source_email
	`)
	if err != nil {
		return fmt.Errorf("failed to query aliases: %w", err)
	}
	defer rows.Close()

	// Group by source (Postfix can have multiple destinations per line)
	aliases := make(map[string][]string)
	for rows.Next() {
		var source, dest string
		if err := rows.Scan(&source, &dest); err != nil {
			continue
		}
		aliases[source] = append(aliases[source], dest)
	}

	// Also query domains for domain-level catchall capability
	domainRows, err := s.db.Query("SELECT domain FROM mail_domains WHERE active = TRUE")
	if err != nil {
		return fmt.Errorf("failed to query domains: %w", err)
	}
	defer domainRows.Close()

	var domains []string
	for domainRows.Next() {
		var domain string
		if err := domainRows.Scan(&domain); err != nil {
			continue
		}
		domains = append(domains, domain)
	}

	// Format: source destination[,destination...]
	content := strings.Builder{}
	content.WriteString("# Generated by PSFX Admin - DO NOT EDIT MANUALLY\n")

	// Add domain entries (for virtual_mailbox_domains)
	for _, domain := range domains {
		content.WriteString(fmt.Sprintf("@%s\t@%s\n", domain, domain))
	}

	content.WriteString("\n# Aliases\n")
	for source, destinations := range aliases {
		content.WriteString(fmt.Sprintf("%s\t%s\n", source, strings.Join(destinations, ", ")))
	}

	// Write and postmap
	if err := atomicWriteFile(s.config.PostfixVirtualAlias, []byte(content.String()), 0644); err != nil {
		return fmt.Errorf("failed to write virtual: %w", err)
	}

	if err := runPostmap(s.config.PostfixVirtualAlias); err != nil {
		return fmt.Errorf("postmap virtual failed: %w", err)
	}

	log.Info().Int("aliases", len(aliases)).Int("domains", len(domains)).Msg("Postfix virtual alias map synced")
	return nil
}

// ReloadServices reloads Dovecot and Postfix to pick up configuration changes
func (s *Syncer) ReloadServices() error {
	// Reload Dovecot
	if err := exec.Command("doveadm", "reload").Run(); err != nil {
		log.Warn().Err(err).Msg("Failed to reload dovecot (may not be running)")
	} else {
		log.Info().Msg("Dovecot reloaded")
	}

	// Reload Postfix
	if err := exec.Command("postfix", "reload").Run(); err != nil {
		log.Warn().Err(err).Msg("Failed to reload postfix (may not be running)")
	} else {
		log.Info().Msg("Postfix reloaded")
	}

	return nil
}

// Helper functions

func atomicWriteFile(path string, data []byte, perm os.FileMode) error {
	// Write to temp file first
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	tmpFile := path + ".tmp"
	f, err := os.OpenFile(tmpFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}

	writer := bufio.NewWriter(f)
	if _, err := writer.Write(data); err != nil {
		f.Close()
		os.Remove(tmpFile)
		return fmt.Errorf("failed to write data: %w", err)
	}

	if err := writer.Flush(); err != nil {
		f.Close()
		os.Remove(tmpFile)
		return fmt.Errorf("failed to flush data: %w", err)
	}

	if err := f.Sync(); err != nil {
		f.Close()
		os.Remove(tmpFile)
		return fmt.Errorf("failed to sync file: %w", err)
	}

	f.Close()

	// Atomic rename
	if err := os.Rename(tmpFile, path); err != nil {
		os.Remove(tmpFile)
		return fmt.Errorf("failed to rename temp file: %w", err)
	}

	return nil
}

func runPostmap(path string) error {
	cmd := exec.Command("postmap", path)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("postmap failed: %s - %w", string(output), err)
	}
	return nil
}

func ensureMailDir(path string, uid, gid int) error {
	// Create directory structure
	if err := os.MkdirAll(path, 0700); err != nil {
		return err
	}

	// Create Maildir structure
	for _, subdir := range []string{"cur", "new", "tmp"} {
		subpath := filepath.Join(path, "Maildir", subdir)
		if err := os.MkdirAll(subpath, 0700); err != nil {
			return err
		}
	}

	// Set ownership (only works if running as root)
	// This will silently fail in containers without proper privileges
	filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
		if err == nil {
			os.Chown(p, uid, gid)
		}
		return nil
	})

	return nil
}
